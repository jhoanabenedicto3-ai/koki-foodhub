{% extends "layouts/base.html" %}
{% block content %}
<div class="forecast-wrapper">
  <div class="page-header">
    <h1 class="section-title">Product Forecast</h1>
    <p class="muted" style="font-size:15px; margin-top:8px;">Predict best-selling products for the next day, week, and month.</p>
  </div>

<style>
  /* Product Forecast Cards (match provided image) */
  .pf-cards { display:grid; grid-template-columns:repeat(3,1fr); gap:20px; margin-bottom:20px; }
  .pf-card { background:#fff; border-radius:12px; padding:20px; box-shadow:0 6px 18px rgba(16,24,40,0.04); border:1px solid #eef2f6; }
  .pf-title { font-size:12px; font-weight:800; color:#94a3b8; letter-spacing:0.06em; }
  .pf-number { font-size:34px; font-weight:900; margin-top:8px; color:#111827; }
  .pf-change { font-size:13px; margin-left:8px; font-weight:700; color:#10b981; }
  .pf-confidence-row { margin-top:10px; font-size:13px; color:#6b7280; }
  .pf-confidence-bar { height:10px; background:#f3f4f6; border-radius:999px; margin-top:6px; overflow:hidden; }
  .pf-confidence-fill { height:100%; width:0%; background:#10b981; border-radius:999px; transition:width .4s ease; }
  .pf-top-items { margin-top:14px; font-size:13px; color:#6b7280; }
  .pf-top-items ul { list-style:none; padding:0; margin:10px 0 0 0; }
  .pf-top-items li { display:flex; justify-content:space-between; align-items:center; padding:10px 0; border-bottom:1px dashed #f3f4f6; }
  .pf-pill { background:#fff; border:1px solid rgba(0,0,0,0.06); padding:6px 10px; border-radius:999px; font-weight:700; font-size:12px; }
  .pf-note { display:inline-block; margin-left:6px; color:#f59e0b; font-weight:700; }
</style>

<div class="pf-cards">
  <div class="pf-card" id="card-day">
    <div class="pf-title">NEXT DAY FORECAST</div>
    <div style="display:flex; align-items:center; gap:8px;">
      <div class="pf-number" id="card-day-amount">—</div>
      <div class="pf-change" id="card-day-change">—</div>
    </div>
    <div class="pf-confidence-row">Confidence Score <span style="float:right;" id="card-day-confidence-pct">—</span>
      <div class="pf-confidence-bar"><div class="pf-confidence-fill" id="card-day-confidence-fill" style="width:0%"></div></div>
    </div>
    <div class="pf-top-items">
      <div style="font-weight:800; font-size:12px; color:#94a3b8;">TOP PREDICTED ITEMS</div>
      <ul id="card-day-top-list"></ul>
    </div>
  </div>

  <div class="pf-card" id="card-week">
    <div class="pf-title">NEXT WEEK FORECAST</div>
    <div style="display:flex; align-items:center; gap:8px;">
      <div class="pf-number" id="card-week-amount">—</div>
      <div class="pf-change" id="card-week-change">—</div>
    </div>
    <div class="pf-confidence-row">Confidence Score <span style="float:right;" id="card-week-confidence-pct">—</span>
      <div class="pf-confidence-bar"><div class="pf-confidence-fill" id="card-week-confidence-fill" style="width:0%"></div></div>
    </div>
    <div class="pf-top-items">
      <div style="font-weight:800; font-size:12px; color:#94a3b8;">TOP PREDICTED ITEMS</div>
      <ul id="card-week-top-list"></ul>
    </div>
  </div>

  <div class="pf-card" id="card-month">
    <div class="pf-title">NEXT MONTH FORECAST</div>
    <div style="display:flex; align-items:center; gap:8px;">
      <div class="pf-number" id="card-month-amount">—</div>
      <div class="pf-change" id="card-month-change">—</div>
    </div>
    <div class="pf-confidence-row">Confidence Score <span style="float:right;" id="card-month-confidence-pct">—</span>
      <div class="pf-confidence-bar"><div class="pf-confidence-fill" id="card-month-confidence-fill" style="width:0%"></div></div>
    </div>
    <div class="pf-top-items">
      <div style="font-weight:800; font-size:12px; color:#94a3b8;">TOP PREDICTED ITEMS</div>
      <ul id="card-month-top-list"></ul>
    </div>
  </div>
</div>



  <!-- Removed legacy chart and trending products per design — only simplified cards are shown above -->
  <div style="height:24px;"></div>

  <div class="card" style="margin-top:18px;">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
      <div>
        <h3 class="section-sub" style="margin:0;">Product Performance</h3>
        <div class="muted" style="font-size:13px; margin-top:4px;">Manage inventory and view sales predictions</div>
      </div>
      <div style="display:flex; gap:8px; align-items:center;">
        <input id="perfSearch" class="input small" placeholder="Search products..." style="min-width:240px;" />
        <select id="rowsPerPage" class="input small" style="width:86px;"><option value="10">10</option><option value="25">25</option><option value="50">50</option></select>
        <button id="downloadReportBtn" class="btn small">Download Report</button>
      </div>
    </div>

    <div style="margin-top:12px; overflow:auto;">
      <table class="table" id="productPerformanceTable" aria-label="Product performance table" style="width:100%;">
        <thead>
          <tr>
            <th style="text-align:left;">Product Name</th>
            <th style="text-align:left;">Category</th>
            <th style="text-align:right;">Last 7 Days</th>
            <th style="text-align:right;">Last 30 Days</th>
            <th style="text-align:center;">Trend</th>
            <th style="text-align:right;">Predicted (Next 7d)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div style="display:flex; justify-content:space-between; align-items:center; margin-top:12px;">
      <div id="perfSummary" class="muted small">Showing 0 results</div>
      <div id="perfPagination"></div>
    </div>
  </div>

  <div id="product-detail" class="card" style="display:none; margin-top:16px; padding:16px;">
    <h3 id="detail-title">Product detail</h3>
    <p id="detail-insight" class="muted">—</p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Enhanced client to fetch product forecast API and render charts + exports
    (function(){
      const apiUrl = '{{ api_url }}';
      let lastProducts = [];
      let currentHorizon = 30;
      let currentCategory = '';
      let currentSearch = '';

      function formatNumber(n){ return (n===0? '0': n.toLocaleString()); }
      function formatCurrency(n){ return '£' + Number(n).toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2}); }

      function renderSummary(summary, best){
        // Legacy small cards - only update if they exist
        const projSalesEl = document.getElementById('proj-sales');
        if(projSalesEl) projSalesEl.innerText = formatNumber(summary.total_forecast_units || 0);
        
        const projSalesMetaEl = document.getElementById('proj-sales-meta');
        if(projSalesMetaEl) projSalesMetaEl.innerText = `${summary.count || 0} products`;
        
        const projRevenueEl = document.getElementById('proj-revenue');
        if(projRevenueEl) projRevenueEl.innerText = formatCurrency(summary.projected_revenue || 0);
        
        const projRevenueMetaEl = document.getElementById('proj-revenue-meta');
        if(projRevenueMetaEl) projRevenueMetaEl.innerText = 'Projected for selected horizon';
        
        // Hero cards - only update if they exist
        const heroProjSalesEl = document.getElementById('hero-proj-sales');
        if(heroProjSalesEl) heroProjSalesEl.innerText = formatNumber(summary.total_forecast_units || 0);
        
        const heroProjSalesMetaEl = document.getElementById('hero-proj-sales-meta');
        if(heroProjSalesMetaEl) heroProjSalesMetaEl.innerText = `${summary.count || 0} products`;
        
        const heroProjRevenueEl = document.getElementById('hero-proj-revenue');
        if(heroProjRevenueEl) heroProjRevenueEl.innerText = formatCurrency(summary.projected_revenue || 0);

        if(best){
          // Small card compatibility - only update if elements exist
          const bestProductEl = document.getElementById('best-product');
          if(bestProductEl) bestProductEl.innerText = best.product + ' — ' + formatNumber(best.forecast_h);
          
          const bestProductMetaEl = document.getElementById('best-product-meta');
          if(bestProductMetaEl) bestProductMetaEl.innerText = 'Confidence: ' + Math.round(best.confidence) + '%';
          
          const bestNameEl = document.getElementById('best-name');
          if(bestNameEl) bestNameEl.innerText = best.product;
          
          const bestForecastEl = document.getElementById('best-forecast');
          if(bestForecastEl) bestForecastEl.innerText = `Forecast: ${formatNumber(best.forecast_h)} Orders`;
          
          const growthVal = Number(best.growth_rate || 0);
          const growthEl = document.getElementById('best-growth');
          if(growthEl){
            if(growthVal > 0){
              growthEl.innerHTML = `<span class="growth-up">+${growthVal}% <span class="trend-icon">▲</span></span>`;
            } else if (growthVal < 0){
              growthEl.innerHTML = `<span class="growth-down">${growthVal}% <span class="trend-icon">▼</span></span>`;
            } else {
              growthEl.innerHTML = `<span class="growth-flat">0% ➜</span>`;
            }
          }

          // Hero fields - only update if elements exist
          const heroBestNameEl = document.getElementById('hero-best-name');
          if(heroBestNameEl) heroBestNameEl.innerText = best.product;
          
          const heroBestMetaEl = document.getElementById('hero-best-meta');
          if(heroBestMetaEl) heroBestMetaEl.innerText = `${formatNumber(best.forecast_h)} • Confidence: ${Math.round(best.confidence)}%`;
          
          // Placeholder image if not available
          const heroImg = document.getElementById('hero-image');
          if(heroImg){
            heroImg.style.background = 'linear-gradient(90deg,#fff,#f5f5f5)';
            heroImg.innerHTML = `
              <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path d="M12 2l2.7 5.6 6.1.9-4.4 4.3 1 6.1L12 17.8 6.6 19.9l1-6.1L3.2 9.5l6.1-.9L12 2z" fill="#FFB300"/>
              </svg>`;
          }

          const bestImg = document.getElementById('best-image');
          if(bestImg){
            bestImg.innerHTML = `
              <svg width="36" height="36" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path d="M12 2l2.7 5.6 6.1.9-4.4 4.3 1 6.1L12 17.8 6.6 19.9l1-6.1L3.2 9.5l6.1-.9L12 2z" fill="#FFB300"/>
              </svg>`;
          }
        } else {
          const bestProductEl = document.getElementById('best-product');
          if(bestProductEl) bestProductEl.innerText = '—';
          
          const bestProductMetaEl = document.getElementById('best-product-meta');
          if(bestProductMetaEl) bestProductMetaEl.innerText = '—';
          
          const heroBestNameEl = document.getElementById('hero-best-name');
          if(heroBestNameEl) heroBestNameEl.innerText = '—';
          
          const heroBestMetaEl = document.getElementById('hero-best-meta');
          if(heroBestMetaEl) heroBestMetaEl.innerText = '—';
        }
      }

      // New: populate the three large forecast cards (day/week/month)
      async function renderForecastCard(horizon, cardPrefix){
        try{
          const params = new URLSearchParams();
          params.set('horizon', horizon);
          params.set('top', '3');
          if(currentCategory) params.set('category', currentCategory);
          if(currentSearch) params.set('search', currentSearch);
          if(document.getElementById('activeOnly')?.checked) params.set('active', '1');
          if(document.getElementById('inStockOnly')?.checked) params.set('in_stock', '1');
          const minP = document.getElementById('minPrice')?.value || '';
          const maxP = document.getElementById('maxPrice')?.value || '';
          if(minP) params.set('min_price', minP);
          if(maxP) params.set('max_price', maxP);

          const res = await fetch(apiUrl + '?' + params.toString(), { credentials: 'same-origin', cache: 'no-store' });
          if(!res.ok){ console.warn('[Product Forecast] API response not ok for renderForecastCard', res.status); const txt = await res.text(); console.warn('[Product Forecast] Response text (start):', txt.slice(0,500)); return; }
          const j = await res.json();
          if(j && j.error){ console.warn('[Product Forecast] API returned error', j); return; }
          const sum = j.summary || {};
          const top = j.top || [];

          // Populate amount (use summary total or sum of top forecasts as fallback)
          const amountEl = document.getElementById(`card-${cardPrefix}-amount`);
          const totalUnits = sum.total_forecast_units !== undefined ? sum.total_forecast_units : (top.reduce((a,b)=>a+(b.forecast_h||0),0));
          if(amountEl){ amountEl.innerText = Number(totalUnits || 0).toLocaleString(); }

          // Simple change: use top[0].growth_rate if available
          const changeEl = document.getElementById(`card-${cardPrefix}-change`);
          if(changeEl && top && top[0]){
            const gv = Number(top[0].growth_rate || 0);
            if(gv > 0){ changeEl.innerText = `+${gv}%`; changeEl.style.color = '#10b981'; }
            else if(gv < 0){ changeEl.innerText = `${gv}%`; changeEl.style.color = '#ef4444'; }
            else { changeEl.innerText = '0%'; changeEl.style.color = '#6b7280'; }
          }

          // Confidence: average confidence of top items
          let confidence = 0;
          if (top && top.length){ confidence = Math.round((top.reduce((a,b)=>a+(b.confidence||0),0) / top.length) || 0); }
          const confPctEl = document.getElementById(`card-${cardPrefix}-confidence-pct`);
          const confFillEl = document.getElementById(`card-${cardPrefix}-confidence-fill`);
          if(confPctEl) confPctEl.innerText = `${confidence}%`;
          if(confFillEl){ confFillEl.style.width = (Math.max(0, Math.min(100, confidence))) + '%';
            if(confidence >= 80) confFillEl.style.background = '#10b981';
            else if(confidence >= 60) confFillEl.style.background = '#f59e0b';
            else confFillEl.style.background = '#ef4444';
          }

          // Top items list
          const listEl = document.getElementById(`card-${cardPrefix}-top-list`);
          if(listEl){ listEl.innerHTML = ''; top.forEach(item => {
              const li = document.createElement('li');
              li.innerHTML = `<span style="font-weight:700; color:#111">${item.product}</span><span class="pf-pill">${Number(item.forecast_h || 0).toLocaleString()} units</span>`;
              listEl.appendChild(li);
          }); }

        }catch(e){ console.warn('renderForecastCard failed', horizon, e); }
      }

      function refreshForecastCards(){ renderForecastCard(1,'day'); renderForecastCard(7,'week'); renderForecastCard(30,'month'); }

      // Ensure cards are refreshed on filter changes
      document.getElementById('categorySelect')?.addEventListener('change', refreshForecastCards);
      document.getElementById('searchInput')?.addEventListener('input', function(){ setTimeout(refreshForecastCards, 400); });
      document.getElementById('activeOnly')?.addEventListener('change', refreshForecastCards);
      document.getElementById('inStockOnly')?.addEventListener('change', refreshForecastCards);
      document.getElementById('minPrice')?.addEventListener('change', refreshForecastCards);
      document.getElementById('maxPrice')?.addEventListener('change', refreshForecastCards);

      // Initial load of cards (after a short delay to let other init complete)
      setTimeout(refreshForecastCards, 300);

      // Export dropdown handlers (guarded in case controls are absent)
      const exportBtnEl = document.getElementById('exportBtn');
      if (exportBtnEl) { exportBtnEl.addEventListener('click', function(ev){ ev.preventDefault(); const menu = document.getElementById('exportMenu'); if(menu) { menu.style.display = (menu.style.display === 'none' || !menu.style.display) ? 'block' : 'none'; } }); }

      const exportCsvMenuEl = document.getElementById('exportCsvMenu'); if(exportCsvMenuEl){ exportCsvMenuEl.addEventListener('click', function(){ exportCSV(); const menu = document.getElementById('exportMenu'); if(menu) menu.style.display = 'none'; }); }
      const exportJsonMenuEl = document.getElementById('exportJsonMenu'); if(exportJsonMenuEl){ exportJsonMenuEl.addEventListener('click', function(){ exportJSON(); const menu = document.getElementById('exportMenu'); if(menu) menu.style.display = 'none'; }); }
      const downloadBtnEl = document.getElementById('downloadBtn'); if(downloadBtnEl){ downloadBtnEl.addEventListener('click', function(){ exportCSV(); }); }

      // Close export menu when clicking outside (guard for missing exportMenu)
      document.addEventListener('click', function(e){ const menu = document.getElementById('exportMenu'); if(!menu) return; if(!e.target.closest('.dropdown') && !e.target.closest('#exportMenu') && menu.style.display === 'block'){ menu.style.display = 'none'; } });

      let barChart = null;
      let lineChart = null;

      function renderBarChart(canvasId, top){
        // Defensive: if Chart.js failed to load (CSP or blocked CDN), avoid throwing and show a placeholder
        if(typeof Chart === 'undefined'){
          const canvas = document.getElementById(canvasId);
          if(canvas){
            const parent = canvas.parentNode;
            if(parent && !parent.querySelector('.chart-unavailable')){
              parent.innerHTML = '<div class="muted small chart-unavailable">Charts unavailable. Please ensure Chart.js is accessible (CDN may be blocked).</div>';
            }
          }
          return;
        }
        const labels = top.map(p => p.product);
        const data = top.map(p => p.forecast_h);
        const el = document.getElementById(canvasId);
        if(!el) return;
        const ctx = el.getContext('2d');
        if(barChart){ try{ barChart.destroy(); }catch(e){} }
        barChart = new Chart(ctx, { type: 'bar', data: { labels, datasets: [{ label: 'Forecast', data, backgroundColor: 'rgba(54, 162, 235, 0.85)' }] }, options: { responsive:true, plugins:{ legend:{ display:false } }, scales:{ y:{ beginAtZero:true } } } });
      }

      // Render product performance table (searchable, paginated) — replaces legacy table
      let perfProducts = [];
      let perfCurrentPage = 1;
      let perfRowsPerPage = 10;

      function renderTable(products){
        // store canonical products for exports and paging
        lastProducts = products;
        perfProducts = (products || []).slice();
        perfCurrentPage = 1;
        renderPerfTablePage();
      }

      function renderPerfTablePage(){
        const tbody = document.querySelector('#productPerformanceTable tbody');
        if(!tbody) return;

        const searchVal = (document.getElementById('perfSearch')?.value || '').toLowerCase().trim();
        const filtered = perfProducts.filter(p => {
          if(!searchVal) return true;
          return (p.product || '').toLowerCase().includes(searchVal) || (p.category || '').toLowerCase().includes(searchVal);
        });

        const total = filtered.length;
        const rowsPerPageEl = document.getElementById('rowsPerPage');
        perfRowsPerPage = rowsPerPageEl ? parseInt(rowsPerPageEl.value,10) : perfRowsPerPage;
        const start = (perfCurrentPage - 1) * perfRowsPerPage;
        const pageItems = filtered.slice(start, start + perfRowsPerPage);

        tbody.innerHTML = '';
        if(total === 0){
          // Show empty message
          const tr = document.createElement('tr');
          tr.innerHTML = '<td colspan="6" style="text-align:center; padding:20px; color:#999;">No products found. Check filters or ensure data exists.</td>';
          tbody.appendChild(tr);
        } else {
          pageItems.forEach((p, i) => {
            const tr = document.createElement('tr');
            const rank = start + i + 1;
            const gv = Number(p.growth_rate || 0);
            const growthMarkup = gv > 0 ? `<span class="growth-up">+${gv}%</span>` : (gv < 0 ? `<span class="growth-down">${gv}%</span>` : `<span class="growth-flat">0%</span>`);
            tr.innerHTML = `
              <td style="white-space:nowrap; font-weight:700;"><a href="#" data-pid="${p.product_id}" class="select-product">${p.product}</a></td>
              <td style="white-space:nowrap; color:#6b7280;">${p.category || ''}</td>
              <td style="text-align:right;">${formatNumber(p.past_7_days || p.past_7 || 0)}</td>
              <td style="text-align:right;">${formatNumber(p.past_30_days || p.past_30 || 0)}</td>
              <td style="text-align:center;">${growthMarkup}</td>
              <td style="text-align:right; font-weight:800; color:#059669;">${formatNumber(p.forecast_h || 0)}</td>
            `;
            tbody.appendChild(tr);
          });
        }

        // summary and pagination
        if(total === 0){
          document.getElementById('perfSummary').innerText = `Showing 0 results`;
        } else {
          document.getElementById('perfSummary').innerText = `Showing ${Math.min(total, start+1)} to ${Math.min(total, start + pageItems.length)} of ${total} results`;
        }
        renderPerfPagination(Math.ceil(total / perfRowsPerPage), perfCurrentPage);

        // attach click handlers for product links
        document.querySelectorAll('.select-product').forEach(a => a.addEventListener('click', function(ev){ ev.preventDefault(); const pid = this.getAttribute('data-pid'); fetchProductDetail(pid); }));
      }

      function renderPerfPagination(totalPages, current){
        const el = document.getElementById('perfPagination');
        if(!el) return; el.innerHTML = '';
        if(totalPages <= 1) return;
        const createBtn = (n, label, active=false) => {
          const b = document.createElement('button');
          b.className = active ? 'btn small active' : 'btn small';
          b.innerText = label || n;
          b.addEventListener('click', function(){ perfCurrentPage = n; renderPerfTablePage(); });
          return b;
        };
        // show simple prev, pages (up to 5), next
        const prev = document.createElement('button'); prev.className='btn small'; prev.innerText='◀'; prev.disabled = current === 1; prev.addEventListener('click', ()=>{ perfCurrentPage = Math.max(1, current-1); renderPerfTablePage(); }); el.appendChild(prev);
        const startPage = Math.max(1, current - 2);
        const endPage = Math.min(totalPages, startPage + 4);
        for(let p = startPage; p <= endPage; p++){ el.appendChild(createBtn(p,p, p===current)); }
        const next = document.createElement('button'); next.className='btn small'; next.innerText='▶'; next.disabled = current === totalPages; next.addEventListener('click', ()=>{ perfCurrentPage = Math.min(totalPages, current+1); renderPerfTablePage(); }); el.appendChild(next);
      }

      // Search and page size handlers for performance table
      const perfSearchEl = document.getElementById('perfSearch'); if(perfSearchEl){ perfSearchEl.addEventListener('input', function(){ perfCurrentPage = 1; setTimeout(renderPerfTablePage, 200); }); }
      const rowsPerPageEl = document.getElementById('rowsPerPage'); if(rowsPerPageEl){ rowsPerPageEl.addEventListener('change', function(){ perfRowsPerPage = parseInt(this.value,10); perfCurrentPage = 1; renderPerfTablePage(); }); }

      // Download report button
      const downloadReportBtn = document.getElementById('downloadReportBtn'); if(downloadReportBtn){ downloadReportBtn.addEventListener('click', function(){ if(!perfProducts || !perfProducts.length){ alert('No data to export'); return; } const headers = ['Product','Category','Past7','Past30','Growth%','Forecast7']; const rows = perfProducts.map(p=> [p.product, p.category, p.past_7_days||p.past_7||0, p.past_30_days||p.past_30||0, p.growth_rate||0, p.forecast_h||0] ); const csv = [headers.join(',')].concat(rows.map(r=>r.map(v=> '"'+String(v).replace(/"/g,'""')+'"').join(','))).join('\n'); const blob = new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='product_performance.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }); }

      function renderLine(canvasId, detail){
        // Defensive: if Chart.js is not available (CDN blocked or CSP), show placeholder and avoid runtime errors
        if(typeof Chart === 'undefined'){
          const canvas = document.getElementById(canvasId);
          if(canvas){
            const parent = canvas.parentNode;
            if(parent && !parent.querySelector('.chart-unavailable')){
              parent.innerHTML = '<div class="muted small chart-unavailable">Chart unavailable. Please ensure Chart.js is accessible (CDN may be blocked).</div>';
            }
          }
          return;
        }

        const labels = (detail.series || []).map(s => s[0]);
        const actual = (detail.series || []).map(s => s[1]);
        const next30 = detail.horizons && detail.horizons.h_30 ? detail.horizons.h_30.forecast : 0;
        const futureLabels = [];
        const forecastVals = [];
        for(let i=1;i<=30;i++){ futureLabels.push('+'+i+'d'); forecastVals.push(next30); }
        const combinedLabels = labels.concat(futureLabels);
        const forecastPadded = Array(labels.length).fill(null).concat(forecastVals);

        const el = document.getElementById(canvasId);
        if(!el) return;
        const ctx = el.getContext('2d');
        if(lineChart){ try{ lineChart.destroy(); }catch(e){} }

        // Create gradient for forecast area (soft shaded fill)
        const g = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
        g.addColorStop(0, 'rgba(235,85,95,0.18)');
        g.addColorStop(1, 'rgba(235,85,95,0.02)');

        lineChart = new Chart(ctx, { type:'line', data:{ labels: combinedLabels, datasets:[
          { label:'Actual', data: actual.concat(Array(futureLabels.length).fill(null)), borderColor: 'rgba(34,139,230,0.95)', backgroundColor: 'rgba(34,139,230,0.08)', fill:true, tension:0.22, pointRadius:2 },
          { label:'Forecast', data: forecastPadded, borderColor:'rgba(235, 85, 95,0.95)', backgroundColor: g, fill:true, borderDash:[6,3], pointRadius:0, tension:0.22 }
        ] }, options:{ responsive:true, plugins:{ tooltip:{ mode:'index', intersect:false } }, scales:{ y:{ beginAtZero:true } } } });
      }

      async function fetchData(){
        try{
          const params = new URLSearchParams();
          params.set('horizon', currentHorizon);
          if(currentCategory) params.set('category', currentCategory);
          if(currentSearch) params.set('search', currentSearch);
          // request a large top to include all products so the table can display full dataset
          params.set('top', '1000');

          const activeOnlyChecked = document.getElementById('activeOnly')?.checked || false;
          const inStockOnlyChecked = document.getElementById('inStockOnly')?.checked || false;
          const minPriceVal = document.getElementById('minPrice')?.value || '';
          const maxPriceVal = document.getElementById('maxPrice')?.value || '';

          if(activeOnlyChecked) params.set('active', '1');
          if(inStockOnlyChecked) params.set('in_stock', '1');
          if(minPriceVal) params.set('min_price', minPriceVal);
          if(maxPriceVal) params.set('max_price', maxPriceVal);

          console.log('[Product Performance] Fetching with URL:', apiUrl + '?' + params.toString());
          const res = await fetch(apiUrl + '?' + params.toString(), { credentials: 'same-origin', cache: 'no-store' });
          console.log('[Product Performance] API response status:', res.status, 'Content-Type:', res.headers.get('content-type'));
          if(!res.ok){ 
            console.warn('[Product Performance] API response not ok for fetchData', res.status); 
            const txt = await res.text(); 
            console.warn('[Product Performance] Response text (full):', txt);
            // Try to parse as JSON error
            try {
              const errJson = JSON.parse(txt);
              console.warn('[Product Performance] Error JSON:', errJson);
            } catch(e) {
              console.warn('[Product Performance] Could not parse error response as JSON');
            }
            return; 
          }
          const json = await res.json();
          console.log('[Product Performance] API returned json keys:', Object.keys(json), 'top count:', (json.top || []).length, 'summary:', json.summary);
          if(json && json.error){ 
            console.warn('[Product Performance] API returned error for fetchData', json); 
            alert('[Product Performance] API Error: ' + (json.error || 'Unknown error'));
            return; 
          }
          const top = json.top || [];
          console.log('[Product Performance] Rendering table with', top.length, 'products, first product:', top[0] || 'none');
          if(top.length === 0){
            console.warn('[Product Performance] No products returned from API - check if products exist in database');
          }
          renderSummary(json.summary || {}, json.best || null);
          renderBarChart('topProductsBar', top.slice(0,10));
          renderTable(top);
        }catch(e){ 
          console.error('[Product Performance] Failed to fetch product forecasts', e); 
          alert('Failed to fetch product data: ' + e.message);
        }
      }

      // Initial load: fetch data when page is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function(){ setTimeout(fetchData, 100); });
      } else {
        // DOM is already ready
        setTimeout(fetchData, 100);
      }
      window.addEventListener('load', function(){ setTimeout(fetchData, 200); });

      async function fetchProductDetail(pid){
        try{
          const params = new URLSearchParams();
          params.set('product_id', pid);
          params.set('horizon', currentHorizon);
          const res = await fetch(apiUrl + '?' + params.toString(), { credentials: 'same-origin', cache: 'no-store' });
          if(!res.ok){ console.warn('[Product Forecast] API response not ok for fetchProductDetail', res.status); const txt = await res.text(); console.warn('[Product Forecast] Response text (start):', txt.slice(0,800)); document.getElementById('product-detail').style.display='none'; return; }
          const j = await res.json();
          if(j && j.error){ console.warn('[Product Forecast] API returned error for fetchProductDetail', j); document.getElementById('product-detail').style.display='none'; return; }
          const d = j.product_detail;
          if(!d){ document.getElementById('product-detail').style.display='none'; return; }
          document.getElementById('product-detail').style.display='block';
          document.getElementById('detail-title').innerText = 'Details: ' + (d.series && d.series.length ? (d.series.slice(-1)[0][0] + ' — ' + d.series.slice(-1)[0][1]) : 'No history');
          document.getElementById('detail-insight').innerText = 'Trend: ' + d.trend + '. Last 7 days: ' + (d.last_7_days || 0) + '. Average daily: ' + (Math.round(d.avg) || 0);
          renderLine('productLineChart', d);
        }catch(e){ console.warn('Failed to fetch product detail', e); }
      }

      // Exports
      function exportCSV(){
        if(!lastProducts || !lastProducts.length){ alert('No data to export'); return; }
        const headers = ['Rank','Product','Past 30d','Forecast','Growth%','Trend','Price','ProjectedRevenue','Category'];
        const rows = lastProducts.map((p,i) => [i+1, p.product, p.past_30_days, p.forecast_h, p.growth_rate, p.trend, p.price, p.projected_revenue, p.category]);
        const csv = [headers.join(',')].concat(rows.map(r => r.map(v => '"'+String(v).replace(/"/g,'""')+'"').join(','))).join('\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `product_forecast_h${currentHorizon}${currentCategory?('_'+currentCategory):''}.csv`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }

      function exportJSON(){
        if(!lastProducts || !lastProducts.length){ alert('No data to export'); return; }
        const blob = new Blob([JSON.stringify(lastProducts, null, 2)], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `product_forecast_h${currentHorizon}${currentCategory?('_'+currentCategory):''}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }

      // Controls
      document.querySelectorAll('.range-btn').forEach(b => {
        b.setAttribute('role', 'tab');
        b.addEventListener('click', function(){
          document.querySelectorAll('.range-btn').forEach(x=>{ x.classList.remove('active'); x.setAttribute('aria-pressed','false'); });
          this.classList.add('active');
          this.setAttribute('aria-pressed','true');
          currentHorizon = parseInt(this.getAttribute('data-range'));
          fetchData();
        });
        // keyboard activation
        b.addEventListener('keydown', function(e){ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); this.click(); } });
      });
      const categorySelectEl = document.getElementById('categorySelect');
      if(categorySelectEl){ categorySelectEl.addEventListener('change', function(){ currentCategory = this.value; fetchData(); }); }
      // category chips behavior (guarded)
      const _chipEls = document.querySelectorAll('.chip');
      if(_chipEls && _chipEls.length){
        _chipEls.forEach(ch => ch.addEventListener('click', function(){
          _chipEls.forEach(x=>x.classList.remove('active'));
          this.classList.add('active');
          currentCategory = this.getAttribute('data-cat');
          const sel = document.getElementById('categorySelect'); if(sel){ sel.value = currentCategory; }
          fetchData();
        }));
      }

      let searchTimer = null;
      const searchInputEl = document.getElementById('searchInput');
      if(searchInputEl){ searchInputEl.addEventListener('input', function(){ clearTimeout(searchTimer); searchTimer = setTimeout(()=>{ currentSearch = this.value.trim(); fetchData(); }, 350); }); }


      // New filters: active, in-stock, price range (guarded)
      const activeOnlyEl = document.getElementById('activeOnly'); if(activeOnlyEl) activeOnlyEl.addEventListener('change', function(){ fetchData(); });
      const inStockOnlyEl = document.getElementById('inStockOnly'); if(inStockOnlyEl) inStockOnlyEl.addEventListener('change', function(){ fetchData(); });
      const minPriceEl = document.getElementById('minPrice'); if(minPriceEl) minPriceEl.addEventListener('change', function(){ fetchData(); });
      const maxPriceEl = document.getElementById('maxPrice'); if(maxPriceEl) maxPriceEl.addEventListener('change', function(){ fetchData(); });

      // Export keyboard support (guarded)
      const exportButton = document.getElementById('exportBtn');
      const exportMenuEl = document.getElementById('exportMenu');
      if(exportButton && exportMenuEl){
        exportButton.addEventListener('keydown', function(e){ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); this.click(); } if(e.key === 'Escape'){ exportMenuEl.style.display='none'; exportMenuEl.setAttribute('aria-hidden','true'); exportButton.setAttribute('aria-expanded','false'); } });
        document.addEventListener('keydown', function(e){ if(e.key === 'Escape'){ if(exportMenuEl.style.display === 'block'){ exportMenuEl.style.display='none'; exportMenuEl.setAttribute('aria-hidden','true'); exportButton.setAttribute('aria-expanded','false'); } } });
      }
      // ensure menu items are keyboard accessible when present
      const ecsv = document.getElementById('exportCsvMenu');
      const ejson = document.getElementById('exportJsonMenu');
      if(ecsv){ ecsv.addEventListener('keydown', function(e){ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); this.click(); } }); }
      if(ejson){ ejson.addEventListener('keydown', function(e){ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); this.click(); } }); }

      // wire hidden/legacy export buttons
      const exportCsvBtn = document.getElementById('exportCsv');
      const exportJsonBtn = document.getElementById('exportJson');
      if(exportCsvBtn) exportCsvBtn.addEventListener('click', exportCSV);
      if(exportJsonBtn) exportJsonBtn.addEventListener('click', exportJSON);

      // Table export controls (new visible ones)
      const exportBtnTable = document.getElementById('exportBtnTable');
      const exportMenuTable = document.getElementById('exportMenuTable');
      if(exportBtnTable && exportMenuTable){
        exportBtnTable.addEventListener('click', function(ev){ ev.preventDefault(); exportMenuTable.style.display = (exportMenuTable.style.display === 'none' || !exportMenuTable.style.display) ? 'block' : 'none'; exportMenuTable.setAttribute('aria-hidden', exportMenuTable.style.display === 'none' ? 'true' : 'false'); exportBtnTable.setAttribute('aria-expanded', exportMenuTable.style.display === 'block' ? 'true' : 'false'); });
        document.getElementById('exportCsvMenuTable').addEventListener('click', function(){ exportCSV(); exportMenuTable.style.display='none'; exportMenuTable.setAttribute('aria-hidden','true'); exportBtnTable.setAttribute('aria-expanded','false'); });
        document.getElementById('exportJsonMenuTable').addEventListener('click', function(){ exportJSON(); exportMenuTable.style.display='none'; exportMenuTable.setAttribute('aria-hidden','true'); exportBtnTable.setAttribute('aria-expanded','false'); });
        // keyboard
        exportBtnTable.addEventListener('keydown', function(e){ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); this.click(); } if(e.key === 'Escape'){ exportMenuTable.style.display='none'; exportMenuTable.setAttribute('aria-hidden','true'); exportBtnTable.setAttribute('aria-expanded','false'); } });
      }

      // Initial load
      fetchData();

    })();
  </script>
</div>
{% endblock %}
